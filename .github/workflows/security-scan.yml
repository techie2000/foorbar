name: Security Scan

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  schedule:
    # Run weekly security scans (Mondays at 9 AM UTC)
    - cron: '0 9 * * 1'
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write

jobs:
  vulnerability-scan:
    name: Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'

      - name: Run Trivy vulnerability scanner in repo mode
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-repo-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-repo-results.sarif'
          category: 'trivy-repo-scan'

      - name: Build Docker image
        run: docker build -t csv2json:latest .

      - name: Run Trivy vulnerability scanner on Docker image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'csv2json:latest'
          format: 'sarif'
          output: 'trivy-image-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Docker scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-image-results.sarif'
          category: 'trivy-docker-scan'

      - name: Run Trivy for issue creation
        id: trivy-check
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'csv2json:latest'
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL,HIGH'
          exit-code: 0

      - name: Parse Trivy results and create issues
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read Trivy results
            let results;
            try {
              results = JSON.parse(fs.readFileSync('trivy-results.json', 'utf8'));
            } catch (error) {
              console.log('No Trivy results file found or parse error');
              return;
            }

            if (!results.Results || results.Results.length === 0) {
              console.log('No vulnerabilities found! ðŸŽ‰');
              return;
            }

            // Group vulnerabilities by package
            const packageVulns = {};

            results.Results.forEach(result => {
              if (result.Vulnerabilities) {
                result.Vulnerabilities.forEach(vuln => {
                  const pkg = vuln.PkgName || 'unknown';
                  const currentVersion = vuln.InstalledVersion || 'unknown';
                  const fixedVersion = vuln.FixedVersion || 'none';

                  if (!packageVulns[pkg]) {
                    packageVulns[pkg] = {
                      current: currentVersion,
                      fixed: fixedVersion,
                      vulns: []
                    };
                  }

                  packageVulns[pkg].vulns.push({
                    id: vuln.VulnerabilityID,
                    severity: vuln.Severity,
                    title: vuln.Title || 'No title',
                    description: vuln.Description || 'No description',
                    references: vuln.References || []
                  });
                });
              }
            });

            // Create or update issues for each package with vulnerabilities
            for (const [pkgName, data] of Object.entries(packageVulns)) {
              // Only create issues for packages with fixes available
              if (data.fixed === 'none' || data.fixed === '') {
                console.log(`Skipping ${pkgName} - no fix available`);
                continue;
              }

              const criticalCount = data.vulns.filter(v => v.severity === 'CRITICAL').length;
              const highCount = data.vulns.filter(v => v.severity === 'HIGH').length;

              const issueTitle = `[Security] Upgrade ${pkgName} from ${data.current} to ${data.fixed}`;
              const priorityLabel = criticalCount > 0 ? 'security-critical' : 'security-high';

              // Check if issue already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: priorityLabel,
                per_page: 100
              });

              const issueExists = existingIssues.data.some(issue =>
                issue.title === issueTitle
              );

              if (issueExists) {
                console.log(`Issue already exists for ${pkgName}`);
                continue;
              }

              // Build issue body
              let issueBody = `## Security Vulnerability Alert\n\n`;
              issueBody += `**Package:** \`${pkgName}\`\n`;
              issueBody += `**Current Version:** \`${data.current}\`\n`;
              issueBody += `**Fixed Version:** \`${data.fixed}\`\n\n`;
              issueBody += `### Vulnerabilities\n\n`;
              issueBody += `- ðŸ”´ Critical: ${criticalCount}\n`;
              issueBody += `- ðŸŸ¡ High: ${highCount}\n\n`;

              issueBody += `### Details\n\n`;
              data.vulns.forEach(vuln => {
                const emoji = vuln.severity === 'CRITICAL' ? 'ðŸ”´' : 'ðŸŸ¡';
                issueBody += `#### ${emoji} ${vuln.id} (${vuln.severity})\n\n`;
                issueBody += `**${vuln.title}**\n\n`;
                issueBody += `${vuln.description}\n\n`;
                if (vuln.references.length > 0) {
                  issueBody += `**References:**\n`;
                  vuln.references.slice(0, 3).forEach(ref => {
                    issueBody += `- ${ref}\n`;
                  });
                  issueBody += `\n`;
                }
              });

              issueBody += `### Recommended Action\n\n`;

              if (pkgName.includes('golang') || pkgName.includes('go')) {
                issueBody += `Update \`go.mod\` and \`Dockerfile\`:\n\n`;
                issueBody += `\`\`\`dockerfile\n`;
                issueBody += `# In Dockerfile builder stage\n`;
                issueBody += `FROM golang:${data.fixed}-alpine3.21\n`;
                issueBody += `\`\`\`\n\n`;
                issueBody += `\`\`\`go\n`;
                issueBody += `// In go.mod\n`;
                issueBody += `go ${data.fixed}\n`;
                issueBody += `\`\`\`\n\n`;
              } else if (pkgName.includes('alpine')) {
                issueBody += `Update \`Dockerfile\` runtime stage:\n\n`;
                issueBody += `\`\`\`dockerfile\n`;
                issueBody += `FROM alpine:${data.fixed}\n`;
                issueBody += `\`\`\`\n\n`;
              } else {
                issueBody += `Update \`Dockerfile\` to use a newer base image or install the fixed version of \`${pkgName}\`.\n\n`;
              }

              issueBody += `After updating, rebuild and test:\n`;
              issueBody += `\`\`\`bash\n`;
              issueBody += `docker-compose build --no-cache\n`;
              issueBody += `go test ./... -v\n`;
              issueBody += `docker-compose up -d\n`;
              issueBody += `\`\`\`\n\n`;
              issueBody += `---\n`;
              issueBody += `*This issue was automatically created by the security scan workflow.*`;

              // Create the issue
              try {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: [priorityLabel, 'security', 'dependencies']
                });
                console.log(`Created issue for ${pkgName}`);
              } catch (error) {
                console.error(`Failed to create issue for ${pkgName}:`, error.message);
              }
            }

      - name: Fail on critical vulnerabilities
        if: steps.trivy-check.outputs.exit-code != '0'
        run: exit 1

  dependency-review:
    name: Dependency Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Dependency Review
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
