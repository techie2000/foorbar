name: Security Scan

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight UTC
  workflow_dispatch:
  push:
    branches: [main, develop]
    paths:
      - 'docker/**'
      - '.github/workflows/security-scan.yml'

jobs:
  security-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      issues: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Backend Docker image
        run: docker build -f docker/Dockerfile.backend -t axiom-backend:latest ./backend

      - name: Run Trivy vulnerability scanner on Backend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'axiom-backend:latest'
          format: 'sarif'
          output: 'trivy-backend-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Backend scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-backend-results.sarif'
          category: 'trivy-backend-scan'

      - name: Build Frontend Docker image
        run: docker build -f docker/Dockerfile.frontend -t axiom-frontend:latest ./frontend

      - name: Run Trivy vulnerability scanner on Frontend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'axiom-frontend:latest'
          format: 'sarif'
          output: 'trivy-frontend-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Frontend scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-frontend-results.sarif'
          category: 'trivy-frontend-scan'

      - name: Run Trivy for issue creation (Backend)
        id: trivy-check-backend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'axiom-backend:latest'
          format: 'json'
          output: 'trivy-backend-issues.json'
          severity: 'CRITICAL,HIGH'
          exit-code: 0

      - name: Run Trivy for issue creation (Frontend)
        id: trivy-check-frontend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'axiom-frontend:latest'
          format: 'json'
          output: 'trivy-frontend-issues.json'
          severity: 'CRITICAL,HIGH'
          exit-code: 0

      - name: Parse Trivy results and create issues (Backend)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read Trivy results
            let results;
            try {
              results = JSON.parse(fs.readFileSync('trivy-backend-issues.json', 'utf8'));
            } catch (error) {
              console.log('No Backend Trivy results file found or parse error');
              return;
            }

            if (!results.Results || results.Results.length === 0) {
              console.log('No backend vulnerabilities found! ðŸŽ‰');
              return;
            }

            // Group vulnerabilities by package
            const packageVulns = {};

            results.Results.forEach(result => {
              if (result.Vulnerabilities) {
                result.Vulnerabilities.forEach(vuln => {
                  const pkg = vuln.PkgName || 'unknown';
                  const currentVersion = vuln.InstalledVersion || 'unknown';
                  const fixedVersion = vuln.FixedVersion || 'none';

                  if (!packageVulns[pkg]) {
                    packageVulns[pkg] = {
                      current: currentVersion,
                      fixed: fixedVersion,
                      vulns: []
                    };
                  }

                  packageVulns[pkg].vulns.push({
                    id: vuln.VulnerabilityID,
                    severity: vuln.Severity,
                    title: vuln.Title || 'No title',
                    description: vuln.Description || 'No description',
                    references: vuln.References || []
                  });
                });
              }
            });

            // Create or update issues for each package with vulnerabilities
            for (const [pkgName, data] of Object.entries(packageVulns)) {
              // Only create issues for packages with fixes available
              if (data.fixed === 'none' || data.fixed === '') {
                console.log(`Skipping ${pkgName} - no fix available`);
                continue;
              }

              const criticalCount = data.vulns.filter(v => v.severity === 'CRITICAL').length;
              const highCount = data.vulns.filter(v => v.severity === 'HIGH').length;

              const issueTitle = `[Security][Backend] Upgrade ${pkgName} from ${data.current} to ${data.fixed}`;
              const priorityLabel = criticalCount > 0 ? 'security-critical' : 'security-high';

              // Check if issue already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: priorityLabel,
                per_page: 100
              });

              const issueExists = existingIssues.data.some(issue =>
                issue.title === issueTitle
              );

              if (issueExists) {
                console.log(`Issue already exists for ${pkgName}`);
                continue;
              }

              // Build issue body
              let issueBody = `## Security Vulnerability Alert - Backend\n\n`;
              issueBody += `**Package:** \\`${pkgName}\`\n`;
              issueBody += `**Current Version:** \\`${data.current}\`\n`;
              issueBody += `**Fixed Version:** \\`${data.fixed}\`\n\n`;
              issueBody += `### Vulnerabilities\n\n`;
              issueBody += `- ðŸ”´ Critical: ${criticalCount}\n`;
              issueBody += `- ðŸŸ¡ High: ${highCount}\n\n`;

              issueBody += `### Details\n\n`;
              data.vulns.forEach(vuln => {
                const emoji = vuln.severity === 'CRITICAL' ? 'ðŸ”´' : 'ðŸŸ¡';
                issueBody += `#### ${emoji} ${vuln.id} (${vuln.severity})\n\n`;
                issueBody += `**${vuln.title}**\n\n`;
                issueBody += `${vuln.description}\n\n`;
                if (vuln.references.length > 0) {
                  issueBody += `**References:**\n`;
                  vuln.references.slice(0, 3).forEach(ref => {
                    issueBody += `- ${ref}\n`;
                  });
                  issueBody += `\n`;
                }
              });

              issueBody += `### Recommended Action\n\n`;

              if (pkgName.includes('golang') || pkgName.includes('go')) {
                issueBody += `Update \\`go.mod\` and \\`docker/Dockerfile.backend\`:\n\n`;
                issueBody += `\`dockerfile\n`;
                issueBody += `# In docker/Dockerfile.backend builder stage\n`;
                issueBody += `FROM golang:${data.fixed}-alpine3.21\n`;
                issueBody += `\`\n\n`;
                issueBody += `\`go\n`;
                issueBody += `// In go.mod\n`;
                issueBody += `go ${data.fixed}\n`;
                issueBody += `\`\n\n`;
              } else if (pkgName.includes('alpine')) {
                issueBody += `Update \\`docker/Dockerfile.backend\` runtime stage:\n\n`;
                issueBody += `\`dockerfile\n`;
                issueBody += `FROM alpine:${data.fixed}\n`;
                issueBody += `\`\n\n`;
              } else {
                issueBody += `Update \`docker/Dockerfile.backend\` to use a newer base image `;
                issueBody += `or install the fixed version of \`${pkgName}\`.\n`;
              }

              issueBody += `After updating, rebuild and test:\n`;
              issueBody += `\`bash\n`;
              issueBody += `docker-compose build --no-cache backend\n`;
              issueBody += `go test ./... -v\n`;
              issueBody += `docker-compose up -d\n`;
              issueBody += `\`\n\n`;
              issueBody += `---\n`;
              issueBody += `*This issue was automatically created by the security scan workflow.*`;

              // Create the issue
              try {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: [priorityLabel, 'security', 'dependencies', 'backend']
                });
                console.log(`Created issue for ${pkgName}`);
              } catch (error) {
                console.error(`Failed to create issue for ${pkgName}:`, error.message);
              }
            }

      - name: Parse Trivy results and create issues (Frontend)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read Trivy results
            let results;
            try {
              results = JSON.parse(fs.readFileSync('trivy-frontend-issues.json', 'utf8'));
            } catch (error) {
              console.log('No Frontend Trivy results file found or parse error');
              return;
            }

            if (!results.Results || results.Results.length === 0) {
              console.log('No frontend vulnerabilities found! ðŸŽ‰');
              return;
            }

            // Group vulnerabilities by package
            const packageVulns = {};

            results.Results.forEach(result => {
              if (result.Vulnerabilities) {
                result.Vulnerabilities.forEach(vuln => {
                  const pkg = vuln.PkgName || 'unknown';
                  const currentVersion = vuln.InstalledVersion || 'unknown';
                  const fixedVersion = vuln.FixedVersion || 'none';

                  if (!packageVulns[pkg]) {
                    packageVulns[pkg] = {
                      current: currentVersion,
                      fixed: fixedVersion,
                      vulns: []
                    };
                  }

                  packageVulns[pkg].vulns.push({
                    id: vuln.VulnerabilityID,
                    severity: vuln.Severity,
                    title: vuln.Title || 'No title',
                    description: vuln.Description || 'No description',
                    references: vuln.References || []
                  });
                });
              }
            });

            // Create or update issues for each package with vulnerabilities
            for (const [pkgName, data] of Object.entries(packageVulns)) {
              // Only create issues for packages with fixes available
              if (data.fixed === 'none' || data.fixed === '') {
                console.log(`Skipping ${pkgName} - no fix available`);
                continue;
              }

              const criticalCount = data.vulns.filter(v => v.severity === 'CRITICAL').length;
              const highCount = data.vulns.filter(v => v.severity === 'HIGH').length;

              const issueTitle = `[Security][Frontend] Upgrade ${pkgName} from ${data.current} to ${data.fixed}`;
              const priorityLabel = criticalCount > 0 ? 'security-critical' : 'security-high';

              // Check if issue already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: priorityLabel,
                per_page: 100
              });

              const issueExists = existingIssues.data.some(issue =>
                issue.title === issueTitle
              );

              if (issueExists) {
                console.log(`Issue already exists for ${pkgName}`);
                continue;
              }

              // Build issue body
              let issueBody = `## Security Vulnerability Alert - Frontend\n\n`;
              issueBody += `**Package:** \\`${pkgName}\`\n`;
              issueBody += `**Current Version:** \\`${data.current}\`\n`;
              issueBody += `**Fixed Version:** \\`${data.fixed}\`\n\n`;
              issueBody += `### Vulnerabilities\n\n`;
              issueBody += `- ðŸ”´ Critical: ${criticalCount}\n`;
              issueBody += `- ðŸŸ¡ High: ${highCount}\n\n`;

              issueBody += `### Details\n\n`;
              data.vulns.forEach(vuln => {
                const emoji = vuln.severity === 'CRITICAL' ? 'ðŸ”´' : 'ðŸŸ¡';
                issueBody += `#### ${emoji} ${vuln.id} (${vuln.severity})\n\n`;
                issueBody += `**${vuln.title}**\n\n`;
                issueBody += `${vuln.description}\n\n`;
                if (vuln.references.length > 0) {
                  issueBody += `**References:**\n`;
                  vuln.references.slice(0, 3).forEach(ref => {
                    issueBody += `- ${ref}\n`;
                  });
                  issueBody += `\n`;
                }
              });

              issueBody += `### Recommended Action\n\n`;

              if (pkgName.includes('node') || pkgName.includes('npm')) {
                issueBody += `Update \\`package.json\` and \\`docker/Dockerfile.frontend\`:\n\n`;
                issueBody += `\`dockerfile\n`;
                issueBody += `# In docker/Dockerfile.frontend builder stage\n`;
                issueBody += `FROM node:${data.fixed}-alpine\n`;
                issueBody += `\`\n\n`;
                issueBody += `Run \\`npm update\` or update specific package in \\`package.json\`\n\n`;
              } else if (pkgName.includes('alpine')) {
                issueBody += `Update \\`docker/Dockerfile.frontend\` runtime stage:\n\n`;
                issueBody += `\`dockerfile\n`;
                issueBody += `FROM alpine:${data.fixed}\n`;
                issueBody += `\`\n\n`;
              } else {
                issueBody += `Update \\`docker/Dockerfile.frontend\\` to use a newer base image `;
                issueBody += `or install the fixed version of \\`${pkgName}\\`.\\n`;
              }

              issueBody += `After updating, rebuild and test:\n`;
              issueBody += `\`bash\n`;
              issueBody += `docker-compose build --no-cache frontend\n`;
              issueBody += `npm test\n`;
              issueBody += `docker-compose up -d\n`;
              issueBody += `\`\n\n`;
              issueBody += `---\n`;
              issueBody += `*This issue was automatically created by the security scan workflow.*`;

              // Create the issue
              try {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: [priorityLabel, 'security', 'dependencies', 'frontend']
                });
                console.log(`Created issue for ${pkgName}`);
              } catch (error) {
                console.error(`Failed to create issue for ${pkgName}:`, error.message);
              }
            }

      - name: Fail on critical vulnerabilities
        if: steps.trivy-check-backend.outputs.exit-code != '0' || steps.trivy-check-frontend.outputs.exit-code != '0'
        run: exit 1
